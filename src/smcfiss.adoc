[[smcfiss]]

== Contributors

Allen Baum, Ruud Derwig, Brian Grayson, Deepak Gupta, Freddie Huang, Yann
Loisel, Ved Shanbhogue, Geoffrey Thorpe, Joe Xie, Adam Zabrocki

== "Smpmpind" Extension for Indirect PMP CSR Access, Version 0.1

The Smpmpind extension defines a range of selector values for accessing PMP
registers using the CSRs provided by the Smcsrind extension. The Smpmpind
extension depends on the Smcsrind extension.

For indirect access to PMP registers, `miselect` selects the target PMP
entry; `mireg` accesses its `pmpaddr` register, and `mireg2` accesses its
`pmpcfg` register. The `mireg3` through `mireg6` are read-only zero.

The `pmpcfg` is a 16-bit register. The low 8 bits of this register are an
alias of the 8-bit field of the PMP configuration register for this entry
that can be accessed using a direct CSR access.

Bit 15 of the `pmpcfg` register is defined as the extended-attributes (`E`)
field. When the `E` field is 0, the `XWR` bits in the `pmpcfg` register are
interpreted as if the `Smpmpind` extension were not implemented. When the `E`
field is 1, the `XWR` bits collectively form a WARL field and all encodings
are reserved unless they are defined by another standard extension.

== "Smcfiss" Extension for Machine-mode Shadow Stack, Version 0.1

The Smcfiss extension enables the use of a shadow stack to enforce
backward-edge control-flow integrity in machine mode.

The Smcfiss extension depends on the Zicfiss and Smpmpind extensions.

The Smcfiss extension introduces an `MSSE` field in `mseccfg` to enable the use
of Zicfiss in machine mode. When the Smcfiss extension is implemented, the
shadow-stack-enabled (SSE) state, denoted by the term `xSSE`, is set to the
value of `mseccfg.MSSE`.

When `mseccfg.MSSE` is 0, the implementation behaves as if the Smcfiss extension
is not implemented. When Smcfiss is implemented, Zicfiss instructions are enabled
for use within machine mode.

When the Smepmp extension is also implemented, if the `mseccfg.RLB` field is 0
while `pmpcfg.L` is 1 in any PMP entry, further writes to the `mseccfg.MSSE` field
are ignored until a PMP reset.

When the Smcfiss extension is implemented, a PMP entry configured with `E=1` and
`XWR=010` denotes an M-mode shadow stack memory region.

When Smcfiss is implemented, the following additional rules apply to memory
accesses with effective privilege mode equal to M:

* Shadow stack instructions are not permitted to access a memory region
  that is not an M-mode shadow stack memory region. Any such attempt
  raises a store/AMO access-fault exception.
* Instructions other than shadow stack instructions are not permitted to
  store to the M-mode shadow stack region. Any such attempt raises a
  store/AMO access-fault exception.
* Implicit accesses, including instruction fetches, to the M-mode shadow
  stack region raise an access-fault exception corresponding to the
  original access type.
* The M-mode shadow stack region may be read either by explicit load
  instructions or by shadow stack instructions.

Accesses to an M-mode shadow stack memory region with an effective privilege
mode less than M raise an access-fault exception corresponding to the original
access type.

== "Smucfiss" Extension for User-mode Shadow Stack for M+U, Version 0.1

The Smucfiss extension enables the use of a shadow stack to enforce
backward-edge control-flow integrity in user mode using PMPs when the S-mode
is not implemented.

The Smucfiss extension depends on the Zicfiss and Smcfiss extensions. Use
of the Smucfiss extension is not supported when the S-mode is implemented.

If `menvcfg.SSE` is 0, the implementation behaves as if Smucfiss is
not implemented.

When Smucfiss is implemented:

* A PMP entry configured with `E=1` and `XWR=110` denotes a U-mode shadow
  stack memory region.
* The shadow-stack-enabled (SSE) state, denoted by the term `xSSE`, is
  set to the value of `menvcfg.SSE` for U-mode, enabling the use of Zicfiss
  in U-mode.

When Smucfiss is implemented, the following additional rules apply to
memory accesses with an effective privilege mode less than M:

* Shadow stack instructions are not permitted to access a memory region
  that is not a U-mode shadow stack memory region. Any such attempt
  raises a store/AMO access-fault exception.
* Instructions other than shadow stack instructions are not permitted to
  store to a U-mode shadow stack memory region. Any such attempt raises a
  store/AMO access-fault exception.
* Implicit accesses, including instruction fetches, to a U-mode shadow
  stack memory region raise an access-fault exception corresponding
  to the original access type.
* A U-mode shadow stack memory region may be read either by explicit
  load instructions or by shadow stack instructions.

== "Sspmpss" Extension for S-level PMP Shadow Stack, Version 0.1

The Sspmpss extension enables the use of a shadow stack to enforce
backward-edge control-flow integrity in supervisor and user modes using S-level
PMPs (SPMP). The Sspmpss extension depends on the Zicfiss and Sspmp extensions.

If `satp.MODE` is not `Bare` or if `menvcfg.SSE` is 0, the implementation
behaves as if Sspmpss is not implemented. When Sspmpss is implemented, the
`XWR=010` encoding in the `spmpcfg[i]` register is defined to represent a shadow
stack memory region.

When Sspmpss is implemented, the following additional rules apply to memory
accesses with effective privilege mode less than M:

* Shadow stack instructions are not permitted to access a memory region
  that is not a shadow stack memory region. Any such attempt raises a store/AMO
  access-fault exception.
* Instructions other than shadow stack instructions are not permitted to
  store to a shadow stack memory region. Any such attempt raises a store/AMO
  access-fault exception.
* Implicit accesses, including instruction fetches, to a shadow stack memory
  region raise an access-fault exception corresponding to the original access
  type.
* Shadow stack memory regions may be read either by explicit load instructions
  or by shadow stack instructions.

The access faults caused by these additional rules occur at lower priority than
a page fault due to the memory access being disallowed by the U bit, given the
effective privilege mode of the access and the state of the `SUM` and `MXR`
fields of the `mstatus` register.

